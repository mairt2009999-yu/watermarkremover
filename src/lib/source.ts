import { type InferPageType, loader } from 'fumadocs-core/source';
import * as LucideIcons from 'lucide-react';
import { createElement } from 'react';
import { author, category, changelog, docs, pages } from '../../.source';
// Import blog directly to avoid fumadocs processing issues
import * as blogRaw from '../../.source';
import { docsI18nConfig } from './docs/i18n';

/**
 * Turn a content source into a unified interface
 * .source folder is generated by `fumadocs-mdx`
 *
 * https://fumadocs.dev/docs/headless/source-api
 */
export const source = loader({
  baseUrl: '/docs',
  source: docs as any,
  i18n: docsI18nConfig,
  icon(iconName) {
    if (!iconName) {
      return undefined;
    }

    const IconComponent = (LucideIcons as Record<string, any>)[iconName];
    if (IconComponent) {
      return createElement(IconComponent);
    }

    console.warn(`Icon not found: ${iconName}`);
    return undefined;
  },
});

/**
 * Changelog source
 */
export const changelogSource = loader({
  baseUrl: '/changelog',
  source: changelog as any,
});

/**
 * Pages source - simplified to avoid fumadocs internal processing issues
 */
export const pagesSource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!pages || !Array.isArray(pages)) {
      return null;
    }

    // Find the page by slug
    const page = (pages as any[]).find((p: any) => {
      const filePath = p.info?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!page) {
      return null;
    }

    return {
      slugs: [page.info?.path?.replace('.mdx', '') || ''],
      data: {
        title: page.data?.title,
        description: page.data?.description,
        date: page.data?.date,
        body: page.data?.body,
      },
      url: `/pages/${page.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!pages || !Array.isArray(pages)) {
      return [];
    }

    return (pages as any[])
      .filter((p: any) => {
        if (!locale) return true;
        const filePath = p.info?.path || '';
        const isLocalized =
          locale === 'zh'
            ? filePath.includes('.zh')
            : !filePath.includes('.zh');
        return isLocalized;
      })
      .map((p: any) => ({
        slugs: [p.info?.path?.replace('.mdx', '').replace('.zh', '') || ''],
        data: {
          title: p.data?.title,
          description: p.data?.description,
          date: p.data?.date,
          body: p.data?.body,
        },
        url: `/pages/${p.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
      }));
  },
};

/**
 * Blog authors source - simplified for collections without i18n
 */
export const authorSource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!author || !Array.isArray(author)) {
      return null;
    }

    // Try to find with locale suffix first if locale is provided
    if (locale) {
      const localizedSlug = `${slug}.${locale}`;
      const localizedAuthor = author.find((a) => {
        const filePath = a._file?.path?.replace('.mdx', '') || '';
        return filePath === localizedSlug;
      });
      if (localizedAuthor) {
        return {
          slugs: [localizedAuthor._file?.path?.replace('.mdx', '') || ''],
          data: {
            name: localizedAuthor.name,
            avatar: localizedAuthor.avatar,
            description: localizedAuthor.description,
            body: localizedAuthor.body,
          },
          url: `/author/${localizedAuthor._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
        };
      }
    }

    // Fallback to non-localized version
    const foundAuthor = author.find((a) => {
      const filePath = a._file?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!foundAuthor) {
      return null;
    }

    return {
      slugs: [foundAuthor._file?.path?.replace('.mdx', '') || ''],
      data: {
        name: foundAuthor.name,
        avatar: foundAuthor.avatar,
        description: foundAuthor.description,
        body: foundAuthor.body,
      },
      url: `/author/${foundAuthor._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!author || !Array.isArray(author)) {
      return [];
    }

    return author.map((a) => ({
      slugs: [a._file?.path?.replace('.mdx', '') || ''],
      data: {
        name: a.name,
        avatar: a.avatar,
        description: a.description,
        body: a.body,
      },
      url: `/author/${a._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
    }));
  },
};

/**
 * Blog categories source - simplified for collections without i18n
 */
export const categorySource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!category || !Array.isArray(category)) {
      return null;
    }

    // Try to find with locale suffix first if locale is provided
    if (locale) {
      const localizedSlug = `${slug}.${locale}`;
      const localizedCategory = category.find((c) => {
        const filePath = c._file?.path?.replace('.mdx', '') || '';
        return filePath === localizedSlug;
      });
      if (localizedCategory) {
        return {
          slugs: [localizedCategory._file?.path?.replace('.mdx', '') || ''],
          data: {
            name: localizedCategory.name,
            description: localizedCategory.description,
            body: localizedCategory.body,
          },
          url: `/category/${localizedCategory._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
        };
      }
    }

    // Fallback to non-localized version
    const foundCategory = category.find((c) => {
      const filePath = c._file?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!foundCategory) {
      return null;
    }

    return {
      slugs: [foundCategory._file?.path?.replace('.mdx', '') || ''],
      data: {
        name: foundCategory.name,
        description: foundCategory.description,
        body: foundCategory.body,
      },
      url: `/category/${foundCategory._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!category || !Array.isArray(category)) {
      return [];
    }

    return category
      .filter((c) => {
        if (!locale) return true;
        const filePath = c._file?.path || '';
        const isLocalized =
          locale === 'zh'
            ? filePath.includes('.zh')
            : !filePath.includes('.zh');
        return isLocalized;
      })
      .map((c) => ({
        slugs: [c._file?.path?.replace('.mdx', '').replace('.zh', '') || ''],
        data: {
          name: c.name,
          description: c.description,
          body: c.body,
        },
        url: `/category/${c._file?.path?.replace('.mdx', '').replace('.zh', '')}`,
      }));
  },
};

/**
 * Blog source - custom implementation with type assertion to avoid TypeScript errors
 */
export const blogSource = {
  getPage(slugs: string[] | undefined, locale?: string) {
    try {
      // Ensure slugs is defined and has at least one element
      if (!slugs || !Array.isArray(slugs) || slugs.length === 0) {
        console.warn('Invalid slugs provided to blogSource.getPage');
        return null;
      }
      
      const slug = slugs[0];
      if (!slug) {
        console.warn('No slug provided to blogSource.getPage');
        return null;
      }
      
      // Use blogRaw.blog to access the raw blog data
      const blogData = (blogRaw as any).blog;
      if (!blogData) {
        console.warn('Blog data is not available');
        return null;
      }
      
      // Cast blog to any[] to avoid TypeScript errors
      const blogArray = blogData as any[];
      
      if (blogArray.length === 0) {
        console.warn('Blog array is empty');
        return null;
      }

      // Find the blog post by slug
      const post = blogArray.find((p: any) => {
        if (!p || typeof p !== 'object') return false;
        // Check both possible property names
        const hasData = p.info && p.data;
        if (!hasData) return false;
        const filePath = p.info?.path?.replace('.mdx', '') || '';
        return filePath === slug;
      });

      if (!post) {
        console.log(`Blog post not found for slug: ${slug}`);
        return null;
      }

      const finalSlug = post.info?.path?.replace('.mdx', '').replace('.zh', '') || '';
      return {
        slugs: [finalSlug],
        data: {
          title: post.data?.title || 'Untitled',
          description: post.data?.description || '',
          date: post.data?.date,
          published: post.data?.published !== false,
          author: post.data?.author || 'watermarkremovertools',
          categories: Array.isArray(post.data?.categories) ? post.data.categories : [],
          image: post.data?.image,
          body: post.data?.body,
        },
        url: `/blog/${finalSlug}`,
      };
    } catch (error) {
      console.error('Error in blogSource.getPage:', error);
      return null;
    }
  },

  getPages(locale?: string) {
    try {
      // Use blogRaw.blog to access the raw blog data
      const blogData = (blogRaw as any).blog;
      if (!blogData) {
        console.warn('Blog data is not available');
        return [];
      }
      
      // Cast blog to any[] to avoid TypeScript errors
      const blogArray = blogData as any[];
      
      if (blogArray.length === 0) {
        console.warn('Blog array is empty');
        return [];
      }

      const allPosts = blogArray
        .filter((p: any) => {
          // Ensure we have valid post data
          if (!p || typeof p !== 'object') {
            console.warn('Invalid post structure:', p);
            return false;
          }
          
          const hasData = p.info && p.data;
          if (!hasData) {
            console.warn('Post missing info or data:', p);
            return false;
          }
          
          // Filter published posts only
          if (p.data?.published === false) {
            return false;
          }
          
          if (!locale) return true;
          const filePath = p.info?.path || '';
          const isLocalized =
            locale === 'zh'
              ? filePath.includes('.zh')
              : !filePath.includes('.zh');
          return isLocalized;
        })
        .map((p: any) => {
          const slug = p.info?.path?.replace('.mdx', '').replace('.zh', '') || '';
          return {
            slugs: [slug],
            data: {
              title: p.data?.title || 'Untitled',
              description: p.data?.description || '',
              date: p.data?.date,
              published: p.data?.published !== false,
              author: p.data?.author || 'watermarkremovertools',
              categories: Array.isArray(p.data?.categories) ? p.data.categories : [],
              image: p.data?.image,
              body: p.data?.body,
            },
            url: `/blog/${slug}`,
          };
        });

      return allPosts;
    } catch (error) {
      console.error('Error in blogSource.getPages:', error);
      return [];
    }
  },
};

export type ChangelogType = InferPageType<typeof changelogSource>;
export type PagesType = ReturnType<typeof pagesSource.getPage>;
export type BlogType = ReturnType<typeof blogSource.getPage>;
export type AuthorType = ReturnType<typeof authorSource.getPage>;
export type CategoryType = ReturnType<typeof categorySource.getPage>;

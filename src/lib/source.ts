import { type InferPageType, loader } from 'fumadocs-core/source';
import * as LucideIcons from 'lucide-react';
import { createElement } from 'react';
// Note: blog import removed to avoid fumadocs flatMap error during build
// Blog data is now handled by blog-data.ts
import { author, category, changelog, docs, pages } from '../../.source';
import { docsI18nConfig } from './docs/i18n';

/**
 * Turn a content source into a unified interface
 * .source folder is generated by `fumadocs-mdx`
 *
 * https://fumadocs.dev/docs/headless/source-api
 */
export const source = loader({
  baseUrl: '/docs',
  source: docs as any,
  i18n: docsI18nConfig,
  icon(iconName) {
    if (!iconName) {
      return undefined;
    }

    const IconComponent = (LucideIcons as Record<string, any>)[iconName];
    if (IconComponent) {
      return createElement(IconComponent);
    }

    console.warn(`Icon not found: ${iconName}`);
    return undefined;
  },
});

/**
 * Changelog source
 */
export const changelogSource = loader({
  baseUrl: '/changelog',
  source: changelog as any,
});

/**
 * Pages source - simplified to avoid fumadocs internal processing issues
 */
export const pagesSource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!pages || !Array.isArray(pages)) {
      return null;
    }

    // Find the page by slug
    const page = (pages as any[]).find((p: any) => {
      const filePath = p.info?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!page) {
      return null;
    }

    return {
      slugs: [page.info?.path?.replace('.mdx', '') || ''],
      data: {
        title: page.data?.title,
        description: page.data?.description,
        date: page.data?.date,
        body: page.data?.body,
      },
      url: `/pages/${page.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!pages || !Array.isArray(pages)) {
      return [];
    }

    return (pages as any[])
      .filter((p: any) => {
        if (!locale) return true;
        const filePath = p.info?.path || '';
        const isLocalized =
          locale === 'zh'
            ? filePath.includes('.zh')
            : !filePath.includes('.zh');
        return isLocalized;
      })
      .map((p: any) => ({
        slugs: [p.info?.path?.replace('.mdx', '').replace('.zh', '') || ''],
        data: {
          title: p.data?.title,
          description: p.data?.description,
          date: p.data?.date,
          body: p.data?.body,
        },
        url: `/pages/${p.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
      }));
  },
};

/**
 * Blog authors source - simplified for collections without i18n
 */
export const authorSource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!author || !Array.isArray(author)) {
      return null;
    }

    // Cast to any to bypass TypeScript strict typing for runtime structure
    const authorArray = author as any[];

    // Try to find with locale suffix first if locale is provided
    if (locale) {
      const localizedSlug = `${slug}.${locale}`;
      const localizedAuthor = authorArray.find((a) => {
        const filePath = a.info?.path?.replace('.mdx', '') || '';
        return filePath === localizedSlug;
      });
      if (localizedAuthor) {
        return {
          slugs: [localizedAuthor.info?.path?.replace('.mdx', '') || ''],
          data: {
            name: localizedAuthor.data.name,
            avatar: localizedAuthor.data.avatar,
            description: localizedAuthor.data.description,
            body: localizedAuthor.data.body,
          },
          url: `/author/${localizedAuthor.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
        };
      }
    }

    // Fallback to non-localized version
    const foundAuthor = authorArray.find((a) => {
      const filePath = a.info?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!foundAuthor) {
      return null;
    }

    return {
      slugs: [foundAuthor.info?.path?.replace('.mdx', '') || ''],
      data: {
        name: foundAuthor.data.name,
        avatar: foundAuthor.data.avatar,
        description: foundAuthor.data.description,
        body: foundAuthor.data.body,
      },
      url: `/author/${foundAuthor.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!author || !Array.isArray(author)) {
      return [];
    }

    // Cast to any to bypass TypeScript strict typing for runtime structure
    const authorArray = author as any[];

    return authorArray.map((a) => ({
      slugs: [a.info?.path?.replace('.mdx', '') || ''],
      data: {
        name: a.data.name,
        avatar: a.data.avatar,
        description: a.data.description,
        body: a.data.body,
      },
      url: `/author/${a.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
    }));
  },
};

/**
 * Blog categories source - simplified for collections without i18n
 */
export const categorySource = {
  getPage(slugs: string[], locale?: string) {
    const slug = slugs[0];
    if (!category || !Array.isArray(category)) {
      return null;
    }

    // Cast to any to bypass TypeScript strict typing for runtime structure
    const categoryArray = category as any[];

    // Try to find with locale suffix first if locale is provided
    if (locale) {
      const localizedSlug = `${slug}.${locale}`;
      const localizedCategory = categoryArray.find((c) => {
        const filePath = c.info?.path?.replace('.mdx', '') || '';
        return filePath === localizedSlug;
      });
      if (localizedCategory) {
        return {
          slugs: [localizedCategory.info?.path?.replace('.mdx', '') || ''],
          data: {
            name: localizedCategory.data.name,
            description: localizedCategory.data.description,
            body: localizedCategory.data.body,
          },
          url: `/category/${localizedCategory.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
        };
      }
    }

    // Fallback to non-localized version
    const foundCategory = categoryArray.find((c) => {
      const filePath = c.info?.path?.replace('.mdx', '') || '';
      return filePath === slug;
    });

    if (!foundCategory) {
      return null;
    }

    return {
      slugs: [foundCategory.info?.path?.replace('.mdx', '') || ''],
      data: {
        name: foundCategory.data.name,
        description: foundCategory.data.description,
        body: foundCategory.data.body,
      },
      url: `/category/${foundCategory.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
    };
  },

  getPages(locale?: string) {
    if (!category || !Array.isArray(category)) {
      return [];
    }

    // Cast to any to bypass TypeScript strict typing for runtime structure
    const categoryArray = category as any[];

    return categoryArray
      .filter((c) => {
        if (!locale) return true;
        const filePath = c.info?.path || '';
        const isLocalized =
          locale === 'zh'
            ? filePath.includes('.zh')
            : !filePath.includes('.zh');
        return isLocalized;
      })
      .map((c) => ({
        slugs: [c.info?.path?.replace('.mdx', '').replace('.zh', '') || ''],
        data: {
          name: c.data.name,
          description: c.data.description,
          body: c.data.body,
        },
        url: `/category/${c.info?.path?.replace('.mdx', '').replace('.zh', '')}`,
      }));
  },
};

/**
 * Blog source is now handled by blog-data.ts to avoid fumadocs build issues
 * See: src/lib/blog-data.ts
 */

// BlogType export for backward compatibility with components
export type BlogType = {
  slugs: string[];
  data: {
    title?: string;
    description?: string;
    date?: string;
    author?: string;
    categories?: string[];
    image?: string;
    published?: boolean;
    body?: any;
  };
  url: string;
};

export type ChangelogType = InferPageType<typeof changelogSource>;
export type PagesType = ReturnType<typeof pagesSource.getPage>;
export type AuthorType = ReturnType<typeof authorSource.getPage>;
export type CategoryType = ReturnType<typeof categorySource.getPage>;
